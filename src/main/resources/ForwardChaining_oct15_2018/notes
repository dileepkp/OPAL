This version is stable. Next version is to test chunking of input and remove (-2 -2 -2) rules
Also removing unused clauses


# Library function call
# fscanf
[fscanfFunCall:
(-2 -2 -2)
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fscanf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
#		print('fscanf func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]


# Assignment Statement fp1 = fp2
[forInitStatement:
(-2 -2 -2)
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		(?right c:referTo ?var2),
		(?left c:hasBaseType c:_IO_FILE)
		(?right c:hasBaseType c:_IO_FILE)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList,rdf:item,?dt)
	
		
->
		
#		print('Skip Assignment Statement type i = j; i not int type'),
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]


[fputcPreCondition:
(-2 -2 -2)
		(1 1 invoke(?exp, ?pp, ?cond)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call pa:hasName  fl:fputc),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:IndirectionOp),
		(?x1 c:hasOperand ?x2),
		(?x2 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
###		print('fputc'),
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('file: fputc')
]



[fclosePostCondition:
(-2 -2 -2)
		(1 1 invoke(?exp, ?pp, ?cond)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call pa:hasName  fl:fclose),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op),
		(?op pa:hasPointerState ?y1), 
		(?y1 pa:atProgramPoint ?pp)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(?y1 pa:stateValue "0"^^xsd:integer),
		(?y1 pa:stateRelation  pa:equals),
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('file: fclose')
]

