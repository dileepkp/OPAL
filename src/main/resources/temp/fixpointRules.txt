@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .
@prefix file0: <ftp:/home/demo/Downloads/PATO-ROSE-master/tools/onto-build-rose/test/word2vec.c#> .

[FixPoint1:
		(1 1 fixpointVerify(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		(2 2 sync(1))
		(?varList rdf:type pa:varList)
		(?varList rdf:item ?var)
		difference(?iter, 1, ?prevIter)
		ge(?iter,2)
		
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?pp pa:afterStatement ?st)
		(?pp pa:iteration ?iter)
		(?ps pa:stateValue ?val)
		strConcat(?val,?lexicalVal)

		(?var pa:hasPointerState ?ps2),
		(?ps2 pa:atProgramPoint ?pp2),
		(?pp2 pa:afterStatement ?st)
		(?pp2 pa:iteration ?prevIter)
		(?ps2 pa:stateValue ?val2)
		strConcat(?val2,?lexicalVal2)

		notEqual(?val,?val2)
->
		remove(0)

		print(?val, ?val2)
		(?forSt pa:fixPointCalc 0)
		(1 1 fixpointCompare(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		print(?iter,'fixpoint1')
]


[FixPoint2:
		(1 1 fixpointVerify(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		(2 2 sync(1))
		(?varList rdf:type pa:varList)
		(?varList rdf:item ?var)
		difference(?iter, 1, ?prevIter)
		ge(?iter,2)

		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?pp pa:afterStatement ?st)
		(?pp pa:iteration ?iter)
		(?ps pa:stateValue ?val)
		strConcat(?val,?lexicalVal)

		(?var pa:hasPointerState ?ps2),
		(?ps2 pa:atProgramPoint ?pp2),
		(?pp2 pa:afterStatement ?st)
		(?ps2 pa:iteration ?prevIter)
		(?ps2 pa:stateValue ?val2)
		strConcat(?val2,?lexicalVal2)

		equal(?val,?val2)
->
		(?forSt pa:fixPointCalc 1)
		(1 1 fixpointCompare(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		print('fixpoint2')
]


[FixPoint3:
		(1 1 fixpointVerify(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		(2 2 sync(1))
		lessThan(?iter,2)

->
		(1 1 completedForIncr(?st,?cond,?forSt,?newI))
		print('fixpoint3')
]


# end for loop
[FixPointCompare:
		(1 1 fixpointCompare(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		noValue(?forSt, pa:fixPointCalc,0)
->
		(1 1 completedForIncr(?st,?cond,?forSt,100))
		(1 1 fixpointRemove(?forSt))
		print('fixpoint compare')
]


# continue for loop
[FixPointCompare2:
		(1 1 fixpointCompare(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		(?forSt pa:fixPointCalc 0)
		lessThan(?iter,3)
->
#		remove(1)
		(?psForIncr pa:stateValue ?newVal)
		(1 1 completedForIncr(?st,?cond,?forSt,?newI))
		(1 1 fixpointRemove(?forSt))
		print('fixpoint compare2')
]


# continue for loop
# if it is third iteration, don't increment for loop variables
[FixPointCompare3:
		(1 1 fixpointCompare(?st,?cond,?forSt,?newI,?iter,?oldVal,?psForIncr,?newVal))
		(?forSt pa:fixPointCalc 0)
		ge(?iter,3)

->
#		remove(1)
		(?psForIncr pa:stateValue ?oldVal)
		(1 1 completedForIncr(?st,?cond,?forSt,?newI))
		(1 1 fixpointRemove(?forSt))
		print('fixpoint compare 3')
]



[FixPointRemove:
		(1 1 fixpointRemove(?forSt))
		(?forSt pa:fixPointCalc ?val)
->
		remove(1)
		print('fixpoint remove')

]


#update other var with iter and create synchrony
[updateOtherVar3:
		(-3 -3 -3)
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		makeTemp(?ps2)
		
->
		(?var pa:hasPointerState ?ps2),
		(?ps2 pa:atProgramPoint ?pp),
		(?pp pa:iteration ?iter)
]

#update programPoint of other vars in loops.
[updateOtherVarInLoop:
		(1 1 updateOtherVarInLoop(?prev,?next,?cond,?pp,?currVar)),
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
->
		(?ps pa:atProgramPoint ?pp)
]






