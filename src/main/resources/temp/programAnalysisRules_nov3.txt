@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .
@prefix file0: <ftp:/home/demo/Downloads/PATO-ROSE-master/tools/onto-build-rose/test/word2vec.c#> .

@include <fileLibraryRules.txt>.
@include <updateOtherVarRules.txt>.


[beginExecution:
#		(?st rdf:type pa:beginExecutionStatement),
		(?st pa:beginExecutionInFunction file0:415_18_420_1 ),
		makeTemp(?pp), 
		makeTemp(?cond),
#list of variables
		makeTemp(?varList)
		
->
#		print('begin execution'),
		(?pp rdf:type pa:ProgramPoint),
		(?cond rdf:type pa:conditionList),
		(?cond rdf:item 'true'),
#		(?cond rdf:rest rdf:nil),
		(?pp pa:afterStatement ?st),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration 0)
		(?varList rdf:type rdf:list),
		(?varList rdf:type pa:varList),
		(?varList pa:count 0)
		(1 1 analyzeStatement(?st, ?pp, ?cond))

]

#A pointer variable declaration without assignment
[analyzeFirstStatement1:
		(1 1 analyzeStatement(?st, ?pp, ?cond)),
		(?st rdf:type c:Variable),
		noValue(?st,c:hasInitializer),
		(?st c:hasType c:pointer_type)
->
		(1 1 makePS(?st, ?pp, ?cond)),
		(1 1 updateVarList(?st))
]

#A long long variable declaration without assignment
[analyzeFirstStatement2:
		(1 1 analyzeStatement(?st, ?pp, ?cond)),
		(?st rdf:type c:Variable),
		noValue(?st,c:hasInitializer),
		(?st c:hasType c:long_long)
->
		(1 1 updateVarList(?st))
		(1 1 makePS(?st, ?pp, ?cond))
		
		print('analyze first statement')
]




###############################################################################################################################
################################ Analyze other types of statements ############################################################

# ForInit Statemen
[forInitStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ForInitStatement)
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		(?right c:hasOperand ?val),
		(?val rdf:type c:Value),
		(?val c:hasValue ?concreteVal),
		(?val c:hasType c:int),
		(?pp pa:iteration ?iter)
		makeTemp(?ps)
->
		
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		print('for init'),
		(?ps pa:stateValue ?concreteVal),
		(?ps pa:stateRelation  pa:equals),
		
		(1 1 completed(?st,?cond,?iter))
(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var))
]


# ForIncr Statemen
[forIncrStatement1:
		(1 1 execute(?prev,?st,?cond,?pp)),
(?st rdf:type c:PostfixIncrementOp)
(?st c:hasParent ?forSt)
		(?forSt c:hasForIncr ?st)
 (?forSt pa:iteration ?i)
		le(?i,2)
		 addOne(?i,?newI)		
		(?st c:hasOperand ?operand)
		(?st c:hasType c:long_long)
		(?operand rdf:type c:VariableRef)
		(?operand c:referTo ?var)
		makeTemp(?ps)
		(?varList rdf:type pa:varList)		
		(?varList rdf:item ?var)
		(?var pa:hasPointerState ?ps2)
		(?ps2 pa:atProgramPoint ?prevPP)
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?iter3)
		(?pp pa:iteration ?iter3)
		(?ps2 pa:stateValue ?concreteVal)
		addOne(?concreteVal,?newVal)
		

->
		remove(0)
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		print('for incr',?i),
		(?ps pa:stateValue ?newVal),
		(?ps pa:stateRelation  pa:equals),
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var)),
		
#		(1 1 fixpointVerify(?st,?cond,?forSt,?newI,?i,?concreteVal,?ps,?newVal))		
		(1 1 completedForIncr(?st,?cond,?forSt,?newI))
		remove(4)


]



# ForIncr Statemen
[forIncrStatement2:
		(1 1 execute(?prev,?st,?cond,?pp)),
(?st rdf:type c:PostfixIncrementOp)
(?st c:hasParent ?forSt)
		(?forSt c:hasForIncr ?st)
 (?forSt pa:iteration ?i)
		ge(?i,3)
		 addOne(?i,?newI)		
		(?st c:hasOperand ?operand)
		(?st c:hasType c:long_long)
		(?operand rdf:type c:VariableRef)
		(?operand c:referTo ?var)
		makeTemp(?ps)
	

->
		remove(0)
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		print('for incr',?i),
		(?ps pa:stateValue pa:constant1),
		(?ps pa:stateRelation  pa:equals),
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var)),
		
#		(1 1 fixpointVerify(?st,?cond,?forSt,?newI,?i,?concreteVal,?ps,?newVal))		
		(1 1 completedForIncr(?st,?cond,?forSt,?newI))
		remove(4)


]


###############################################################################################################################
################################ Analyze file library statements ##############################################################


# Variable declaration with function call of library
[varDecFuncCall:
		(1 1 execute(?prev,?var,?cond,?pp)),
		(?var rdf:type c:Variable),
		(?var c:hasType c:pointer_type),
		(?var c:hasInitializer ?init),
		(?init rdf:type c:AssignInitializer),
		(?init c:hasInitialValue ?func),
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fopen'),
		makeTemp(?ps)
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?call pa:hasName  fl:fopen),
		(1 1 invoke(?var, ?pp, ?cond)),
		(1 1 updateVarList(?var))
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,?var)),
#		(1 1 makePS(?var, ?pp, ?cond))
]


# Library function call
# fputc(*Data,f);
[fputcFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputc'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:IndirectionOp),
		(?x1 c:hasOperand ?x2),
		(?x2 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
->
		(?call pa:hasName  fl:fputc)
		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1))
print('fputc')
]



# Library function call
# fprintf
[fprintfFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fprintf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
		print('fprintf func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1))
		(1 1 completed(?exp,?cond,?iter))
]

# fclose(f);
[fcloseFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fclose'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op)
		makeTemp(?ps)
->
		(?op pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?call pa:hasName  fl:fclose),
		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?op))
print('fclose')
]


############################################################################################################################
################################ Analyze If and loop statements ############################################################


# Analyze If statement.
[IfStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement)
		(?pp pa:iteration ?iter)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1)),
		(1 1 createYesConditionList(?st,?cond,?exp,?iter)),
		(1 1 createNoConditionList(?st,?cond,?exp,?iter))
print('if stmnt')
]

# Analyze For statement
[ForStatement1:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement),
		(?st c:hasParent ?forSt),
		(?forSt rdf:type c:ForStatement),
		noValue(?forSt, pa:iteration)
		(?forSt c:hasForTest ?st)
		(?pp pa:iteration ?iter)
->

		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
		(1 1 createNoConditionList(?st,?cond,?st,?iter))		
		(1 1 createYesConditionList2(?st,?cond,?st,1,?prev,?pp))

		(?forSt pa:iteration 1)
		print('for st1')
]

# Analyze For statement.
[ForStatement2:
		(1 1 execute2(?prev,?st,?cond,?pp,?newI))
		(?st rdf:type c:ExpressionStatement)
		(?st c:hasParent ?forSt)
		(?forSt rdf:type c:ForStatement)
		(?forSt c:hasForTest ?st)
		ge(?newI,2)
		le(?newI,3)
#		equal(?newI,2)
		(?pp pa:iteration ?iter)
->

		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
		(1 1 createYesConditionList2(?st,?cond,?st,?newI,?prev,?pp))
		(?forSt pa:iteration ?newI)
#		(1 1 createNoConditionList(?st,?cond,?exp,?iter))
print('for st2')
]

# Analyze For statement.
[ForStatement3:
		(1 1 execute2(?prev,?st,?cond,?pp,?newI)),
		(?st rdf:type c:ExpressionStatement),
		(?st c:hasParent ?forSt),
		(?forSt rdf:type c:ForStatement),
		(?forSt c:hasForTest ?st)

		equal(?newI,4)
		(?pp pa:iteration ?iter)
->
#		(?forSt pa:iteration 4)
#		(1 1 completed(?forSt,?cond))
#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1)),
#		(1 1 createYesConditionList(?st,?cond,?exp,?iter)),
		(1 1 createNoConditionList2(?st,?cond,?st,?newI,?prev,?pp))
#		(?forSt pa:totalIterations ?iter)
print('for st3')
]




# Analyze return statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ReturnStatement)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
print('return')
]

# If the true conditional block of a if-else statement has a return statement, then 
# the rest of function has a negated condition.
# disabled temporarily
[IfStatementWithReturn:
		(-2 -2 -2),
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement),
		(?st c:hasTrueBody ?trueBody),
		(?trueBody rdf:type c:Block),
		(?return rdf:type c:ReturnStatement),
		(?return c:hasParent  ?trueBody),
		(?st pa:afterIfBlock ?afterIf)
->
		(?afterIf pa:inheritsCondition negOf(?exp))
]

# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1)),
		(1 1 totalIterations(?st,?cond,?iter))
		(1 1 completed(?st,?cond,?iter))
print('dummy cfg exit')
]


############################################################################################################################
################################ Make Variable states and conditions #######################################################

# yes and No condition list can be merged?


[createYesConditionList:
		(1 1 createYesConditionList(?prev,?cond,?exp,?iter)),
		makeTemp(?cond2)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),
#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
		(1 1 completedYesCondition(?prev,?cond2,?iter))
print(' yes condition')
]



[createYesConditionList:
		(1 1 createYesConditionList2(?prev,?cond,?exp,?iter,?prevprev,?pp)),
		makeTemp(?cond2)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),
		(1 1 updateOtherVar(?prevprev,?prev,?cond2,?pp,1))
		(1 1 completedYesCondition(?prev,?cond2,?iter))
print(' yes condition 2')
]


[createNoConditionList:
		(1 1 createNoConditionList(?prev,?cond,?exp,?iter)),
		makeTemp(?cond2)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),
		(1 1 completedNoCondition(?prev,?cond2,?iter)),
	print('completed no condition')
]



[createNoConditionList2:
		(1 1 createNoConditionList2(?prev,?cond,?exp,?iter,?prevprev,?pp)),
		makeTemp(?cond2)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),
		(1 1 updateOtherVar(?prevprev,?prev,?cond2,?pp,1))
		(1 1 completedNoCondition(?prev,?cond2,?iter)),
	print('completed no condition2')
]


# Different ways of making variable states
[makePointerState1:
		(1 1 makePS(?var, ?pp, ?cond)),
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(1 1 completed(?var,?cond,?iter))
		(1 1 updateOtherVarCompleted(?var,?cond))
# print('make ps')
]

# List of variables
[updateVarList:
		(1 1 updateVarList(?st))
		(?varList rdf:type pa:varList)
		(?varList pa:count ?c)
		addOne(?c,?c1)
		noValue(?varList,rdf:item,?st)
		(?st rdf:type c:Variable)
->
		(?varList rdf:item ?st)
		(?varList pa:count ?c)

]

[updateOtherVar0:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
		noValue(pa:otherVarCount ?t2 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
->
		(pa:otherVarCount 0 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
]


[updateOtherVar0:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
		noValue(pa:otherVarCount ?t2 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
->
		(pa:otherVarCount 0 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
]

#update programPoint of other vars.
#applied when prev is not cfg exit of for statement
#when prev and next are in same iteration
[updateOtherVar:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
		(pa:otherVarCount ?cnt updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		addOne(?cnt,?cnt1)
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?iter)
		(?pp pa:iteration ?iter)
		noValue(1,1,totalIterations(?prev,?cond,?iter2))
		
->
		(?ps pa:atProgramPoint ?pp)
		print('update other Var 1',?var,'st:',?next)
#		(11 ?var updateOtherVar(?prev,?next,?cond,?pp,?currVar))

]

#if the prev is cfg exit of for loop, consider only the last iteration

#update programPoint of other vars.
#applied when prev is cfg exit of for statement
[updateOtherVar2:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
		(1 1 totalIterations(?prev,?cond,?iter))
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		strConcat(?prev,?prev2)
		regex(?prev2,'.*exit$')
		
#		(?prev2 c:hasParent ?parentPrevPP)
#		(?parentPrevPP rdf:type c:ForStatement)
#		(?parentPrevPP  pa:totalIterations ?iter)
		(?prevPP pa:iteration ?iter)
		
		makeTemp(?pp4)
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
->
		(?pp4 pa:afterStatement ?next),
		(?pp4 pa:hasProgramConditions ?cond),
		(?pp4 pa:iteration 0)

#		(?ps pa:atProgramPoint ?pp)
		(?ps pa:atProgramPoint ?pp4)
#		(21 ?var updateOtherVar(?prev,?next,?cond,?pp4,?currVar))
print('updateOtherVar2',?var,'st:',?next)

]

#applied within loops
[updateOtherVar3:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)

		(?prevPP pa:iteration ?iter)
		addOne(?iter,?iter3)
		(?pp pa:iteration ?iter2)
		equal(?iter2,?iter3)
		
->

		(?ps pa:atProgramPoint ?pp)
		print('update other Var 3',?var,'st:',?next)
#		(13 ?var updateOtherVar(?prev,?next,?cond,?pp,?currVar))

]


##################################################################################################################
################################ Pass Control ####################################################################

# if the previous statement is not a conditional
[passControl:
		(1 1 completed(?prev,?cond,?iter)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
		(?prev pa:nextStatement ?next),
		makeTemp(?pp)
->

		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next,'pass control 1','iter',?iter)
		print('')
]


[passControl4:
		(1 1 completedForIncr(?prev,?cond,?forSt,?i)),
		(?prev pa:nextStatement ?next),
		makeTemp(?pp)
->

		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?i)
		(1 1 execute2(?prev,?next,?cond,?pp,?i)),
		print(?prev, ?next, 'pass control 4')
		print('pass control4')
		print('')
]


# if the previous statement is an If conditional
[passControl2:
		(1 1 completedYesCondition(?prev,?cond,?iter)),
		(?prev pa:nextTrueStatement ?next),
		makeTemp(?pp)
->
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'true','iter',?iter)
		print('')
]

# if the previous statement is an If conditional
[passControl3:
		(1 1 completedNoCondition(?prev,?cond,?iter)),
		(?prev pa:nextFalseStatement ?next),
		makeTemp(?pp)
->
		
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'false')
		print('')
]


		






