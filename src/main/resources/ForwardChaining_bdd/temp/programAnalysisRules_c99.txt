@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .
# @prefix file0: <ftp:/home/demo/Downloads/PATO-ROSE-master/tools/onto-build-rose/test/word2vec.c#> .

@include <ForwardChaining/fileLibraryRules.txt>.
@include <ForwardChaining/loopRules.txt>.
@include <ForwardChaining/statementRules.txt>.
# @include <ForwardChaining/functionRules.txt>.
@include <ForwardChaining/varDeclRules.txt>.
@include <ForwardChaining/skipRules.txt>.


[beginExecution:
#		(?st rdf:type pa:beginExecutionStatement),
		(?st pa:beginExecutionInFunction ?func ),
		makeTemp(?pp), 
		makeTemp(?cond),
#list of variables
		makeTemp(?varList)
		makeTemp(?loopList)
		makeTemp(?intDataTypeList)
		makeTemp(?ignoreFuncCalls)
		makeTemp(?arithmeticOp)
		makeTemp(?fileLibrary)
		
->
		print('begin execution',?func, ?st),
		(?pp rdf:type pa:ProgramPoint),
		(?cond rdf:type pa:conditionList),
		(?cond rdf:item 'true'),
#		(?cond rdf:rest rdf:nil),
		(?pp pa:afterStatement ?st),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration 0)
		(?pp pa:baseConditions ?cond)
		(?varList rdf:type rdf:list),
		(?varList rdf:type pa:varList),
		(?varList pa:inFunction ?func)
		(?varList pa:inPath ?cond)
		(?varList pa:count 0)
		(?varList pa:baseConditions ?cond)
		(?loopList rdf:type pa:loopList)
		(?loopList rdf:item c:ForStatement)
		(?loopList rdf:item c:WhileStatement)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item c:int)
		(?intDataTypeList rdf:item c:long_long)
		(?intDataTypeList rdf:item c:long)
		(?intDataTypeList rdf:item c:unsigned_long)
		(?intDataTypeList rdf:item c:unsigned_int)

		(?arithmeticOp rdf:type pa:arithmeticOperators)
		(?arithmeticOp rdf:item c:DivOp)
		(?arithmeticOp rdf:item c:ModOp)		
		(?arithmeticOp rdf:item c:SubOp)		
		(?arithmeticOp rdf:item c:AddOp)

		(?ignoreFuncCalls rdf:type pa:ignoreFuncCalls)
		(?ignoreFuncCalls rdf:item 'ungetc')
#		(?ignoreFuncCalls rdf:item 'strcpy')
#		(?ignoreFuncCalls rdf:item 'printf')
#		(?ignoreFuncCalls rdf:item 'scanf')
		
		(?fileLibrary rdf:type pa:FileLibrary)
		(?fileLibrary pa:hasFunction 'fopen')
		(?fileLibrary pa:hasFunction 'fread')
		(?fileLibrary pa:hasFunction 'fwrite')
		(?fileLibrary pa:hasFunction 'fclose')
		(?fileLibrary pa:hasFunction 'fgetc')
		(?fileLibrary pa:hasFunction 'fputc')
		(?fileLibrary pa:hasFunction 'fgets')
		(?fileLibrary pa:hasFunction 'fputs')
		(?fileLibrary pa:hasFunction 'ftell')
		(?fileLibrary pa:hasFunction 'fprintf')
		(?fileLibrary pa:hasFunction 'fscanf')
		(?fileLibrary pa:hasFunction 'fseek')
		(?fileLibrary pa:hasFunction 'ungetc')
		
		(1 1 analyzeStatement(?st, ?pp, ?cond))
		(1 1 execute(pa:firstStatement,?st,?cond,?pp))

]


[callAFunction:
		(?st pa:firstStatementInFunction ?func )
		(?st pa:callFunction ?func)
		(?st pa:conditions ?cond)
		makeTemp(?pp), 
#list of variables
		makeTemp(?varList)
		makeTemp(?loopList)
		
->
###		print('begin execution'),
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?st),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration 0)
		(?pp pa:baseConditions ?cond)
		(?varList rdf:type rdf:list),
		(?varList rdf:type pa:varList),
		(?varList pa:inFunction ?func)
		(?varList pa:inPath ?cond)
		(?varList pa:count 0)
		(?varList pa:baseConditions ?cond)
		(?loopList rdf:type pa:loopList)
		(?loopList rdf:item c:ForStatement)
		(?loopList rdf:item c:WhileStatement)
		print('called a Function','beign st',?st)
		(1 1 analyzeStatement(?st, ?pp, ?cond))

]



############################################################################################################################
################################ Analyze If and loop statements ############################################################


# Analyze If statement.
[IfStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),
#		(1 1 createYesConditionList(?st,?cond,?exp,?iter,?baseConditions)),
#		(1 1 createNoConditionList(?st,?cond,?exp,?iter,?baseConditions))
#		(1 1 createYesConditionList2(?st,?cond,?exp,?iter,?baseConditions,?prev,?pp)),
#		(1 1 createNoConditionList2(?st,?cond,?exp,?iter,?baseConditions,?prev,?pp))
				
		print('if stmnt 1')
]


# Analyze If statement.
[IfStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(1 1 updateOtherVarCompleted(?st,?cond))
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

->
		remove(1)
#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),
		(1 1 createNoConditionList(?st,?cond,?exp,?iter,?baseConditions,?st))
		(1 1 createYesConditionList(?st,?cond,?exp,?iter,?baseConditions)),

		(?st pa:previousIterationIndex_0 ?iter)
		(?st pa:previousIterationIndex_1 ?iter)
		

#		(1 1 createYesConditionList2(?st,?cond,?exp,?iter,?baseConditions,?prev,?pp)),
#		(1 1 createNoConditionList2(?st,?cond,?exp,?iter,?baseConditions,?prev,?pp))
				
		print('if stmnt 2')
]



# Analyze return statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ReturnStatement)
#		(?ret rdf:type c:NullExpr)
		(?ret c:hasParent ?st)
		noValue(?ret, c:hasBaseType, c:_IO_FILE)
		(?pp pa:iteration ?iter)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('return')
]

# Analyze return statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ReturnStatement)
		(?ret c:hasParent ?st )
		(?ret c:referTo ?var)
		(?ret c:hasBaseType c:_IO_FILE)
		(?pp pa:iteration ?iter)
->
		(1 1 makePS2(?var , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
		print('return with Value')
]


# Analyze break statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:BreakStatement)
		(?pp pa:iteration ?iter)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('break')
]

# Analyze Continue statement.
[ContinueStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ContinueStatement)
		(?pp pa:iteration ?iter)
		
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('Continue')
]


# exit
[exitFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'exit'),
#		(?func c:hasArgumentExpr ?y),
#		(?y c:NthArg "0"),
#		(?y c:referTo ?op)
#		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(1 1 makePS2(?op , ?pp, ?cond,"0"^^xsd:integer,pa:equals))
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
#		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('exit')
]




# If the true conditional block of a if-else statement has a return statement, then 
# the rest of function has a negated condition.
# disabled temporarily
[IfStatementWithReturn:
		(-2 -2 -2),
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement),
		(?st c:hasTrueBody ?trueBody),
		(?trueBody rdf:type c:Block),
		(?return rdf:type c:ReturnStatement),
		(?return c:hasParent  ?trueBody),
		(?st pa:afterIfBlock ?afterIf)
->
		(?afterIf pa:inheritsCondition negOf(?exp))
]

# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?par pa:previousIterationIndex_0 ?index)
		(?par pa:iterationIndexEnable_0 ?cond)			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
->
		remove(0)
		remove(1)
		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),
#		(1 1 totalIterations(?st,?cond,?iter,?var,?index))
		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false',?st)
]



# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExitTest:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(1 1 execute(?prev,ftp:/home/demo/pato/tools/onto-build-rose/test/spec/feat.c#520_2_526_2_exit,?cond,?pp))
		(?par pa:previousIterationIndex_0 ?index)
		(?par pa:iterationIndexEnable_0 ?cond2)			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
->
#		remove(0)
#		remove(1)
#		remove(2)
#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

#		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false test',?st)
]

# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?par pa:previousIterationIndex_1 ?index)	
		(?par pa:iterationIndexEnable_1 ?cond)	
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		
->
		remove(0)		
		remove(1)
		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),
#		(1 1 totalIterations(?st,?cond,?iter,?var,?index))
		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true',?st)
]


############################################################################################################################
################################ Make Variable states and conditions #######################################################


[createrVarList:
		(1 pa:output ?op)
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		makeTemp(?varList2)

		(?varList rdf:type pa:varList)
#		(?varList pa:count ?c)
		(?varList pa:baseConditions ?baseConditions)
		(?varList pa:inPath ?cond)
->
		(?varList2 rdf:type pa:varList),
		(?varList2 pa:inPath ?cond2)
		(?varList2 pa:count 0)
		(?varList2 pa:baseConditions ?baseConditions)
		(?varList pa:copy ?varList2)
#		print('create var list in new path',?cond2)
]

[copyVarList:
		(1 pa:output ?op)
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		(?varList pa:count ?c)
		(?varList2 pa:count ?c2)
		addOne(?c2,?c3)
		(?varList pa:inPath ?cond)
		(?varList2 pa:inPath ?cond2)
		greaterThan(?c,?c2)
		(?varList pa:copy ?varList2)

		noValue(?varList2,rdf:item,?st)
		(?st rdf:type c:Variable)
		(?varList rdf:item ?st)

->
		(?varList2 rdf:item ?st)
		remove(3)
		(?varList2 pa:count ?c3)
#		(1 1 ?op)
#		remove(0)
#		remove(1)
#		print('copy var',?st)
]

[copyVarListCompleted:
		(1 pa:output ?op)
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		(1 pa:output2 ?op2)
		(?varList pa:count ?c)
		(?varList2 pa:count ?c2)
		(?varList pa:inPath ?cond)
		(?varList2 pa:inPath ?cond2)
		equal(?c,?c2)
		(?varList pa:copy ?varList2)

->
#		(?varList2 rdf:item ?st)
		(1 1 ?op)
		(1 1 ?op2)
		remove(0)
		remove(1)
		remove(2)
		print('copy var list in new path completed',?cond2)
]



# yes and No condition list can be merged?


[createYesConditionList:
		(1 1 createYesConditionList(?prev,?cond,?exp,?iter,?baseConditions)),
		makeTemp(?cond2)
		

->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),
#		(1 1 updateOtherVarCompleted(?prev,?cond2))
#		(1 1 completedYesCondition(?prev,?cond2,?iter,?baseConditions))
		(?prev pa:iterationIndexEnable_1 ?cond2)
		print(' yes condition',?prev)
		
		(1 pa:output completedYesCondition(?prev,?cond2,?iter,?baseConditions))
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		(1 pa:output2 updateOtherVarCompleted(?prev,?cond2))

]



[createNoConditionList:
		(1 1 createNoConditionList(?prev,?cond,?exp,?iter,?baseConditions,?forSt)),
		makeTemp(?cond2)
		
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),
#		(1 1 updateOtherVarCompleted(?prev,?cond2))
#		(1 1 completedNoCondition(?prev,?cond2,?iter,?baseConditions)),
		(?forSt pa:iterationIndexEnable_0 ?cond2)
		print('completed no condition',?prev)

		(1 pa:output completedNoCondition(?prev,?cond2,?iter,?baseConditions))
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		(1 pa:output2 updateOtherVarCompleted(?prev,?cond2))

]

#called only from forSt1 and forSt2
[createYesConditionList2:
		(1 1 createYesConditionList2(?prev,?cond,?exp,?iter,?baseConditions,?prevprev,?pp)),
#		difference(?iter,1,?prevIter),
		makeTemp(?cond2)
		makeTemp(?pp2)
		
		(?prevPP pa:afterStatement ?prevprev),
		(?prevPP pa:hasProgramConditions ?cond),
		(?prevPP pa:iteration ?prevIter)
		(?prevPP pa:baseConditions ?baseConditions)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond2),
		(?pp2 pa:iteration ?iter)
		(?pp2 pa:baseConditions ?baseConditions)

#		(1 1 updateOtherVar(?prevprev,?prev,?cond2,?pp2,1,?prevIter,?iter))
#		(1 1 completedYesCondition(?prev,?cond2,?iter,?baseConditions))
		print(' yes condition 2','prevprev',?prevprev,'prev',?prev)

		(1 pa:output completedYesCondition(?prev,?cond2,?iter,?baseConditions))
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		(1 pa:output2 updateOtherVar(?prevprev,?prev,?cond2,?pp2,1,?prevIter,?iter))


]


#called only from forSt3
[createNoConditionList2:
		(1 1 createNoConditionList2(?prev,?cond,?exp,?iter,?baseConditions,?prevprev,?pp,?forSt)),
#		difference(?iter,1,?prevIter),
		makeTemp(?cond2)

		(?prevPP pa:afterStatement ?prevprev),
		(?prevPP pa:hasProgramConditions ?cond),
		(?prevPP pa:iteration ?prevIter)
		(?prevPP pa:baseConditions ?baseConditions)
		
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),
#		(1 1 updateOtherVar(?prevprev,?prev,?cond2,?pp,1,?prevIter,?iter))
#		(1 1 completedNoCondition(?prev,?cond2,?iter,?baseConditions)),
		(?forSt pa:iterationIndexEnable_1 ?cond2)
		print('completed no condition2','prevprev',?prevprev,'prev',?prev)

		(1 pa:output completedNoCondition(?prev,?cond2,?iter,?baseConditions))
		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))
		(1 pa:output2 updateOtherVar(?prevprev,?prev,?cond2,?pp,1,?prevIter,?iter))

]


# Different ways of making variable states
[makePointerState1:
		(1 1 makePS(?var, ?pp, ?cond)),
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(1 1 completed(?var,?cond,?iter,?baseConditions))
		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make ps',?var)
]

[makePointerState2:
		(1 1 makePS2(?var, ?pp, ?cond,?stateVal, ?stateRel))
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		noValue(1,1,updateVarList(?var,?z1))
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		remove(0)
#		(1 1 completed(?var,?cond,?iter))
#		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make ps2')
]

[makeFilePointerState:
		(1 1 makeFilePS(?var, ?pp, ?cond,?stateVal, ?stateRel,?resource))
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		noValue(1,1,updateVarList(?var,?z1))
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:pointsToResource ?resource),
		(?ps pa:atProgramPoint ?pp),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		remove(0)
#		(1 1 completed(?var,?cond,?iter))
#		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make file ps')
]

[makePointerState_completed:
		(1 1 makePS_comp(?var, ?pp, ?cond,?stateVal, ?stateRel))
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		noValue(1,1,updateVarList(?var,?z1))
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		remove(0)
#		(1 1 completed(?var,?cond,?iter))
		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make ps_other var completed')
]

		

# List of variables
[updateVarList:
		(1 1 updateVarList(?st,?baseConditions,?cond))
		(?varList rdf:type pa:varList)
		(?varList pa:count ?c)
		addOne(?c,?c1)
		noValue(?varList,rdf:item,?st)
		(?st rdf:type c:Variable)
		(?varList pa:baseConditions ?baseConditions)

		(?varList pa:inPath ?cond)
		(?varList pa:inFunction ?func)
		(?st c:hasScope ?func)

->
		(?varList rdf:item ?st)
		remove(0)
		remove(2)
		(?varList pa:count ?c1)

		print('varList', ?c1, ?func)

]

[updateOtherVar0:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		noValue(pa:otherVarCount ?t2 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		notEqual(?currVar,1)
		noValue(1, 1, makePS2(?next, ?pp, ?cond,?stateVal, ?stateRel))
		noValue(1,1,updateVarList(?currVar,?z1))
		noValue(1,1,makeFilePS(?next, ?pp, ?cond,?stateVal, ?stateRel,?resource))
#		noValue(1,pa:parameterList)


# (?varList rdf:type pa:varList)
#		(?varList pa:inPath ?cond)
#		(?varList pa:count ?zzzz)

->
		(pa:otherVarCount 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 0_1',?next)
#		print('var count',?c)
]


[updateOtherVar0:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		noValue(pa:otherVarCount ?t2 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		equal(?currVar,1)
		noValue(1, 1, makePS2(?next, ?pp, ?cond,?stateVal, ?stateRel))
		noValue(1,1,updateVarList(?z2,?z1))
		noValue(1,1,makeFilePS(?next, ?pp, ?cond,?stateVal, ?stateRel,?resource))
#		noValue(1,pa:parameterList,parameter(?next,?cond,?iter,?t2,?t1))
# parameter(?next,?cond,?iter,?baseConditions,?zzz)
# this should be present in the above line...
# updateOtherVar should start only after variables are copied into the new path
 
#(?varList rdf:type pa:varList)
#		(?varList pa:inPath ?cond)
#		(?varList pa:count ?c)


->
		(pa:otherVarCount 0 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 0_0',?next)
#		print('var count',?c)
]

#update programPoint of other vars.
#applied when prev is not cfg exit of for statement
#when prev and next are in same iteration
[updateOtherVar:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		(pa:otherVarCount ?cnt updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		addOne(?cnt,?cnt1)
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		(?varList pa:baseConditions ?baseConditions)
		(?varList pa:inPath ?cond)
		(?pp pa:baseConditions ?baseConditions)		
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?prevIter)
		(?pp pa:iteration ?iter)
#		noValue(1,1,totalIterations(?prev,?cond,?iter2,?var,?index))
		noValue(?ps pa:atProgramPoint ?pp)
		
->
		(?ps pa:atProgramPoint ?pp)
		remove(1)
		(pa:otherVarCount ?cnt1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 1',?var,'st:',?next)
#		(11 ?var updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#(1 1 updateOtherVarProcessed(?prev,?next,?cond,?pp,?currVar))

]



#applied within loops
[updateOtherVar3:
(-2 -2 -2)
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar)),
(pa:otherVarCount ?cnt updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		addOne(?cnt,?cnt1)
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		(?varList pa:baseConditions ?baseConditions)
		(?varList pa:inPath ?cond)
		(?pp pa:baseConditions ?baseConditions)		
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)

		(?prevPP pa:iteration ?iter)
		addOne(?iter,?iter3)
		(?pp pa:iteration ?iter2)
		equal(?iter2,?iter3)

		noValue(?ps pa:atProgramPoint ?pp)
		
->

		(?ps pa:atProgramPoint ?pp)
		remove(1)
		(pa:otherVarCount ?cnt1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 3',?var,'st:',?next)
#		(13 ?var updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#(1 1 updateOtherVarProcessed(?prev,?next,?cond,?pp,?currVar))

]

[updateOtherVarComplete:
		(?varList rdf:type pa:varList)
		(?varList pa:count ?c)
		(pa:otherVarCount ?cnt1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		equal(?c,?cnt1)
		(?varList pa:baseConditions ?baseConditions)
		(?varList pa:inPath ?cond)
		(?pp pa:baseConditions ?baseConditions)		
		
->
		remove(2)
		(1 1 updateOtherVarCompleted(?next,?cond))
#		(?cond pa:lastExecSt ?next)
#		print('update other var remove','count',?c,'st',?next)
]


##################################################################################################################
################################ Pass Control ####################################################################

# if the previous statement is not a conditional
[passControl:
		(1 1 completed(?prev,?cond,?iter,?baseConditions)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
		noValue(?prev, pa:lastStatementInLoop)
		(?prev pa:nextStatement ?next),
		makeTemp(?pp)
->
#		remove(1)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next,'pass control 1','iter',?iter)
		print('')
]


[passControl4:
		(1 1 completedForIncr(?prev,?cond,?forSt,?i,?baseConditions)),
#		(1 1 updateOtherVarCompleted(?prev,?cond))
# removed comment of above line on jan 3, 2018
		(?prev pa:nextStatement ?next),
		makeTemp(?pp)
->
		remove(0)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?i)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute2(?prev,?next,?cond,?pp,?i)),
		print(?prev, ?next, 'pass control 4')
		print('')
]


# if the previous statement is an If conditional
[passControl2:
		(1 1 completedYesCondition(?prev,?cond,?iter,?baseConditions)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
		(?prev pa:nextTrueStatement ?next),
		makeTemp(?pp)
->
#		remove(1)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'true','iter',?iter)
		print('')
]

# if the previous statement is an If conditional
[passControl3:
		(1 1 completedNoCondition(?prev,?cond,?iter,?baseConditions)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
#removed comment above line on feb 6
		(?prev pa:nextFalseStatement ?next),
		makeTemp(?pp)
#		(-2 -2 -2)
->

		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'false')
		print('')
]


