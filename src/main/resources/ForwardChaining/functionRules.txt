@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .
# @prefix file0: <ftp:/home/demo/Downloads/PATO-ROSE-master/tools/onto-build-rose/test/word2vec.c#> .


############################################################################################################################
################ Inter-procedural calls, to be handled in future ############################################################



# inter-procedural function call
# if the function call has same name and one of the paremeters
# is of FILE type
[
(-2 -2 -2)
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg ?argPos),
		(?y c:referTo ?var)
		(?y c:hasBaseType c:_IO_FILE)
		
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation  ?stateRel),
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?iter)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

		(?callee rdf:type c:FunctionDecl)
		(?callee c:hasName ?funcName )
		(?callee c:hasParameter ?parameter )
		(?parameter c:NthPara ?argPos )
		noValue(?callee,c:hasDefinition,?funcBody )
		(?parameter rdf:type c:Variable )
		(?parameter c:hasBaseType c:_IO_FILE )
		(?parameter c:hasType c:pointer_type )

		noValue(100,100,100)


		
->
		(?parameter pa:hasPointerState ?ps)

		(100 100 100)		

#		print('IP call no def', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]

############################################################################################################################
################################ General rules #############################################################################




[rule1:
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?var c:hasType ?dt)
		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item ?dt)

		(?func rdf:type c:FunctionCall)
->
		(?left pa:type pa:returnHandlerScalar)

]

[rule2:
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?var c:hasType c:pointer_type)
		(?var c:hasBaseType ?dt)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item ?dt)

		(?func rdf:type c:FunctionCall)
->
		(?left pa:type pa:returnHandlerPointer)

]


[rule3:
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?var c:hasType c:pointer_type)
		(?var c:hasBaseType c:_IO_FILE)


		(?func rdf:type c:FunctionCall)
->
		(?left pa:type pa:returnHandlerPointer)

]

[rule4:
		(?vardecl rdf:type c:VariableDecl)
		(?vardecl c:hasInitializer ?initializer)
		(?vardecl c:hasType ?dt)
		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item ?dt)

		(?initializer rdf:type c:AssignInitializer)
		(?initializer c:hasInitialValue ?right)
		(?right rdf:type c:FunctionCall)

->
		(?vardecl pa:type pa:returnHandlerScalar)

]

[rule5:
		(?vardecl rdf:type c:VariableDecl)
		(?vardecl c:hasInitializer ?initializer)
		(?vardecl c:hasType c:pointer_type)
		(?vardecl c:hasBaseType ?dt)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item ?dt)

		(?initializer rdf:type c:AssignInitializer)
		(?initializer c:hasInitialValue ?right)
		(?right rdf:type c:FunctionCall)

->
		(?vardecl pa:type pa:returnHandlerPointer)

]


[rule6:
		(?vardecl rdf:type c:VariableDecl)
		(?vardecl c:hasInitializer ?initializer)
		(?vardecl c:hasType c:pointer_type)
		(?vardecl c:hasBaseType c:_IO_FILE)

		(?initializer rdf:type c:AssignInitializer)
		(?initializer c:hasInitialValue ?right)
		(?right rdf:type c:FunctionCall)

->
		(?vardecl pa:type pa:returnHandlerPointer)

]






############################################################################################################################
################################ Function calls  ##########################################################################



# Skip function call return values not caught; func()
[SkipIPCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),

		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
#		noValue(?func, c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		
->
#		print('Skip IP call with no parameters', 'iter', ?iter),
		processArguments(?func, ?pp)
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]



# ch = Skip function call unhandled return values; ch = func()
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		noValue(?left, pa:type, pa:returnHandlerScalar)
		noValue(?left, pa:type, pa:returnHandlerPointer)


		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
		
#		noValue(?func,c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		print('Skip function call with no parameters and unhandled return values', 'iter', ?iter),
		processArguments(?func, ?pp)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]

# function calls  scalar return values; ch = func()
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?left pa:type pa:returnHandlerScalar)


		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
		
#		noValue(?func,c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		print('function calls with no parameters and scalar return values', 'iter', ?iter),
		processArguments(?func, ?pp)
		(1 1 makePS2(?var , ?pp, ?cond,pa:unknown,pa:equals))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]

# function calls with handled-pointer return values; ch = func()
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?left pa:type pa:returnHandlerPointer)


		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
		
#		noValue(?func,c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		makeTemp(?resource)
->
#		print('function calls with no parameters and handled-pointer return values', 'iter', ?iter),
		processArguments(?func, ?pp)
		(1 1 makeFilePS(?var , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual,?resource))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]




##########################################################################################################################
################################ variable declarations with function calls  ##############################################

		

#(1 1 execute(?prev,?st,?cond,?pp)),
#		(?st rdf:type c:ExpressionStatement )
#		(?st c:hasExpression ?expr )
#		(?expr rdf:type c:AssignOp )
#		(?expr c:hasLeftOperand ?left )
#		(?expr c:hasRightOperand ?func )
#		(?left rdf:type c:VariableRef )
#		(?left c:referTo ?var )



# ch = Skip function call unhandled return values; ch = func()
# function calls  scalar return values; ch = func()
# function calls with handled-pointer return values; ch = func()
[rule:
		
		(1 1 execute(?prev,?var,?cond,?pp))
		(?var rdf:type c:VariableDecl)
		(?var c:hasInitializer ?initializer)
		(?var c:hasType ?dt)
		(?initializer rdf:type c:AssignInitializer)
		(?initializer c:hasInitialValue ?func)
		(?func rdf:type c:FunctionCall)
		noValue(?var, pa:type, pa:returnHandlerScalar)
		noValue(?var, pa:type, pa:returnHandlerPointer)

		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
		
#		noValue(?func,c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
	

#		print('Skip function call unhandled return values', 'iter', ?iter),
		processArguments(?func, ?pp)
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?var,?cond,?iter,?baseConditions))


]



[rule:
		
		(1 1 execute(?prev,?var,?cond,?pp))
		(?var rdf:type c:VariableDecl)
		(?var c:hasInitializer ?initializer)
		(?var c:hasType ?dt)
		(?initializer rdf:type c:AssignInitializer)
		(?initializer c:hasInitialValue ?func)
		(?func rdf:type c:FunctionCall)

		(?var pa:type pa:returnHandlerScalar)
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
		
#		noValue(?func,c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
	
#		print('function calls  scalar return values', 'iter', ?iter),
		(1 1 makePS2(?var , ?pp, ?cond,pa:unknown,pa:equals))
		processArguments(?func, ?pp)
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?var,?cond,?iter,?baseConditions))


]



[rule:
		
		(1 1 execute(?prev,?var,?cond,?pp))
		(?var rdf:type c:VariableDecl)
		(?var c:hasInitializer ?initializer)
		(?var c:hasType ?dt)
		(?initializer rdf:type c:AssignInitializer)
		(?initializer c:hasInitialValue ?func)
		(?func rdf:type c:FunctionCall)

		(?var pa:type pa:returnHandlerPointer)
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?handledFunctions rdf:type pa:HandledFunctions)		
		noValue(?handledFunctions, pa:hasFunction, ?funcName)		
		
#		noValue(?func,c:hasArgumentExpr, ?y),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
	

	
#		print('function calls with handled-pointer return values', 'iter', ?iter),
		(1 1 makeFilePS(?var , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual,?resource))
		processArguments(?func, ?pp)
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?var,?cond,?iter,?baseConditions))


]


