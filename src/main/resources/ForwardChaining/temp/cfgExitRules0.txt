@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .


##################################################################################################################################
################################ false rules #####################################################################################

# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_0 ?index)
#		(?par pa:iterationIndexEnable_0 ?cond2)			
		(?par pa:iterationIndex func0(?cond2,?index))

		equal(?cond,?cond2)
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
->
		remove(0)
#		remove(1)
#		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false',?st)
]




# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_0 ?index)
#		(?par pa:iterationIndexEnable_0 ?cond2)
		(?par pa:iterationIndex func0(?cond2,?index))
			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)

		(?cond rdf:item ?cond2)
		notEqual(?cond,?cond2)



->
		remove(0)
#		remove(1)
#		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false2',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_0 ?index)
#		(?par pa:iterationIndexEnable_0 ?cond2)
		(?par pa:iterationIndex func0(?cond2,?index))
			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)

->
		remove(0)
#		remove(1)
#		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false3',?st)
]



# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_0 ?index)
#		(?par pa:iterationIndexEnable_0 ?cond2)
		(?par pa:iterationIndex func0(?cond2,?index))
			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond4)
		(?cond4 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		notEqual(?cond4,?cond2)



->
		remove(0)
#		remove(1)
#		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false4',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_0 ?index)
#		(?par pa:iterationIndexEnable_0 ?cond2)
		(?par pa:iterationIndex func0(?cond2,?index))
			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond4)
		(?cond4 rdf:item ?cond5)
		(?cond5 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		notEqual(?cond4,?cond2)
		notEqual(?cond5,?cond2)



->
		remove(0)
#		remove(1)
#		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false5',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_0 ?index)
#		(?par pa:iterationIndexEnable_0 ?cond2)
		(?par pa:iterationIndex func0(?cond2,?index))
			
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond4)
		(?cond4 rdf:item ?cond5)
		(?cond5 rdf:item ?cond6)
		(?cond6 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		notEqual(?cond4,?cond2)
		notEqual(?cond5,?cond2)
		notEqual(?cond6,?cond2)



->
		remove(0)
#		remove(1)
#		remove(2)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit false6',?st)
]

