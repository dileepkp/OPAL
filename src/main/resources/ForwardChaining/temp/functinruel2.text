
















# Postfix and prefix operations global
[PostfixIncrement:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?st),		
		
#		(?st rdf:type c:PostfixIncrementOp)
#		(?st c:hasParent ?forSt)
		noValue(?forSt, c:hasForIncr, ?st)

		(?st c:hasOperand ?operand)
		(?st c:hasType ?dt)
		(?operand rdf:type c:VariableRef)
		(?operand c:referTo ?var)
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)
	
		(?varList rdf:type pa:varList)		
		noValue(?varList,rdf:item,?var)
		(?varList pa:baseConditions ?baseConditions)

	
	
		
->
		remove(0)
#		print('PostfixIncrement global',?ps2),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter)),
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]


# PostfixDecrement
[PostfixDecrement:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?st),		
		
		(?st rdf:type c:PostfixDecrementOp)
		(?st c:hasParent ?forSt)
		noValue(?forSt, c:hasForIncr, ?st)

		(?st c:hasOperand ?operand)
		(?st c:hasType ?dt)
		(?operand rdf:type c:VariableRef)
		(?operand c:referTo ?var)
		makeTemp(?ps)
		(?pp pa:baseConditions ?baseConditions)
		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item ?dt)
	
		(?varList rdf:type pa:varList)		
		(?varList rdf:item ?var)
		(?varList pa:baseConditions ?baseConditions)

		(?var pa:hasPointerState ?ps2)
		(?ps2 pa:atProgramPoint ?prevPP)
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?iter)
		(?pp pa:iteration ?iter)
		(?prevPP pa:baseConditions ?baseConditions)
		(?ps2 pa:stateValue ?concreteVal)
		isLiteral(?concreteVal)
		difference(?concreteVal,1,?newVal)
	
		
->
		remove(0)

		(1 1 makePS2(?var, ?pp, ?cond,?newVal, pa:equals))
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?var,?iter,?iter)),
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]









# Assignment Statement; Assign constant to a scalar variable
[
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		(?right rdf:type c:Value),
		(?right c:hasValue ?concreteVal),
		(?right c:hasType c:int),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

		(?pp pa:baseConditions ?baseConditions)	
->
		
		(1 1 makePS2(?var , ?pp, ?cond,?concreteVal,pa:equals))

		(1 1 completed(?st,?cond,?iter,?baseConditions))
(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
]

