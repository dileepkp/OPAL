@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .





# Variable declaration with function call of library
#File * fp = fopen(..);
[varDecFuncCall:
		(1 1 execute(?prev,?var,?cond,?pp)),
		(?var rdf:type c:Variable),
		(?var c:hasType c:pointer_type),
		(?var c:hasInitializer ?init),
		(?init rdf:type c:AssignInitializer),
		(?init c:hasInitialValue ?func),
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fopen'),
		makeTemp(?ps)
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)
->
#		(?var pa:hasState ?ps),
#		(?ps pa:atProgramPoint ?pp),
#		(?call pa:hasName  fl:fopen),
#		(1 1 invoke(?var, ?pp, ?cond)),
# function call is the resource

		(1 1 updateVarList(?var,?baseConditions,?cond))
		(1 1 makePointerPS(?var , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual,?func))
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,?var,?iter,?iter)),
		(1 1 completed(?var,?cond,?iter,?baseConditions))
#		print('file var declaration with fopen')

]


# fp = fopen(..);
[fopenReturn2: 
		(1 1 execute(?prev,?exp,?cond,?pp))
		(?exp rdf:type c:ExpressionStatement )
		(?exp c:hasExpression ?func )
		(?func rdf:type c:AssignOp )
		(?func c:hasLeftOperand ?left )
		(?func c:hasRightOperand ?funcCall )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?expRef )
		(?funcCall rdf:type c:FunctionCall)
		(?funcCall c:call ?call)
		(?call c:hasName 'fopen')

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(1 1 makePointerPS(?expRef , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual,?funcCall))

		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?expRef,?iter,?iter)),
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('file: fopen2')
]



#A file pointer variable declaration without assignment 
#File *f in parameter list
#Disabled this as a general rule is available in functionRules.txt
[analyzeFirstStatement1:
		(-2 -2 -2)
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:Variable),
		(?st c:hasType c:pointer_type)
		(?st c:hasBaseType c:_IO_FILE)
		(?st c:NthPara ?paraNum)
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)
->

		(1 1 updateVarList(?st,?baseConditions,?cond))
		(1 1 makePS2(?st , ?pp, ?cond,pa:unknown,pa:equals))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?st,?iter,?iter)),
		(1 1 completed(?st,?cond,?iter,?baseConditions))
#		print('file parameter in function parameter list')
]


#A pointer file variable declaration without assignment (moved to pointerRules.txt)
# Assignment Statement fp1 = fp2 (moved to pointerRules.txt)





###############################################################################################################################
################################ Analyze file library statements ##############################################################



# Library function call
# fputc(*Data,f);
[fputcFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputc'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:IndirectionOp),
		(?x1 c:hasOperand ?x2),
		(?x2 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('fputc')
]



# Library function call
# fputc(*Data,f);
[fputcFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputc'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:VariableRef),
#		(?x1 c:hasOperand ?x2),
		(?x1 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('fputc 2')
]


# Library function call
# fputs(" ",f);
[fputsFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputs'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),

		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:Value),
#		(?x1 c:hasOperand ?x2),
#		(?x2 c:referTo ?op1),

		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('fputs')
]

# ch = fgetc(fin);
[fgetcCall:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fgetc'),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		print('fgetc func call', 'iter', ?iter),
		(1 1 makePS2(?var , ?pp, ?cond,pa:unknown,pa:equals))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]


# ch = ftell(fin);
[ftellCall:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?hro )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?hro c:hasOperand ?func)
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'ftell'),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		print('ftell func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]


# Library function call
# fprintf
[fprintfFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fprintf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
#		print('fprintf func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]


# Library function call
# fseek
[fseekFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fseek'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		print('fseek func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]



# Library function call
# fscanf
[fscanfFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fscanf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "2"),
		(?y c:hasOperand ?op)
		(?op c:referTo ?op2)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
#		print('fscanf2 func call', 'iter', ?iter),
		(1 1 makePS2(?op2 , ?pp, ?cond,"0"^^xsd:integer,pa:equals))
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?op2,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]





# Library function call
# ungetc
[ungetcFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

		(?ignoreFuncCalls rdf:type pa:ignoreFuncCalls)
		(?ignoreFuncCalls rdf:item ?funcName)
->

#		print('ignore func call', ?funcName),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]

# fclose(f);
[fcloseFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fclose'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op)
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
#		(?op pa:hasState ?ps),
#		(?ps pa:atProgramPoint ?pp),
#		(?call pa:hasName  fl:fclose),
#		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 makePS2(?op , ?pp, ?cond,"0"^^xsd:integer,pa:equals))
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?op,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
#		print('fclose')
]




