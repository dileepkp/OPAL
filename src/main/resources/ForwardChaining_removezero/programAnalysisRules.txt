@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .
@prefix file0: <ftp:/home/demo/pato/tools/onto-build-rose/test/spec/feat.c#> .

@include <ForwardChaining/fileLibraryRules.txt>.
@include <ForwardChaining/loopRules.txt>.
@include <ForwardChaining/statementRules.txt>.
# @include <ForwardChaining/functionRules.txt>.
@include <ForwardChaining/varDeclRules.txt>.
@include <ForwardChaining/skipRules.txt>.
@include <ForwardChaining/cfgExitRules.txt>.



[beginExecution:

		(?st pa:beginExecutionInFunction ?func ),
		makeTemp(?pp), 
		makeTemp(?cond),
#list of variables
		makeTemp(?varList)
		makeTemp(?loopList)
		makeTemp(?intDataTypeList)
		makeTemp(?ignoreFuncCalls)
		makeTemp(?arithmeticOp)
		makeTemp(?fileLibrary)
		
->
		remove(0)
		print('begin execution',?func, ?st),
		(?pp rdf:type pa:ProgramPoint),

		(?cond rdf:type rdf:List)
		(?cond rdf:first 'true'),
		(?cond rdf:rest rdf:nil),	

		(?cond rdf:type pa:conditionList),
		(?cond rdf:item 'true'),
#		(?cond rdf:rest rdf:nil),
		
		(?pp pa:afterStatement ?st),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration 0)
		(?pp pa:baseConditions ?cond)
		(?varList rdf:type rdf:list),
		(?varList rdf:type pa:varList),
		(?varList pa:inFunction ?func)
#		(?varList pa:inPath ?cond)
		(?varList pa:count 0)
		(?varList pa:baseConditions ?cond)
		
		(?loopList rdf:type pa:loopList)
		(?loopList rdf:item c:ForStatement)
		(?loopList rdf:item c:WhileStatement)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		(?intDataTypeList rdf:item c:int)
		(?intDataTypeList rdf:item c:long_long)
		(?intDataTypeList rdf:item c:long)
		(?intDataTypeList rdf:item c:unsigned_long)
		(?intDataTypeList rdf:item c:unsigned_int)

		(?arithmeticOp rdf:type pa:arithmeticOperators)
		(?arithmeticOp rdf:item c:DivOp)
		(?arithmeticOp rdf:item c:ModOp)		
		(?arithmeticOp rdf:item c:SubOp)		
		(?arithmeticOp rdf:item c:AddOp)
		(?arithmeticOp rdf:item c:MulOp)
		(c:ArithmeticAssignOp rdf:item c:AddAssignOp)
		(c:ArithmeticAssignOp rdf:item c:SubAssignOp)
		(c:ArithmeticAssignOp rdf:item c:MulAssignOp)
		(c:ArithmeticAssignOp rdf:item c:DivAssignOp)		

		(?ignoreFuncCalls rdf:type pa:ignoreFuncCalls)
		(?ignoreFuncCalls rdf:item 'ungetc')
#		(?ignoreFuncCalls rdf:item 'strcpy')
#		(?ignoreFuncCalls rdf:item 'printf')
#		(?ignoreFuncCalls rdf:item 'scanf')

		(?fileLibrary rdf:type pa:FileLibrary)
		(?fileLibrary pa:hasFunction 'fopen')
#		(?fileLibrary pa:hasFunction 'fread')
#		(?fileLibrary pa:hasFunction 'fwrite')
		(?fileLibrary pa:hasFunction 'fclose')
		(?fileLibrary pa:hasFunction 'fgetc')
		(?fileLibrary pa:hasFunction 'fputc')
		(?fileLibrary pa:hasFunction 'fgets')
		(?fileLibrary pa:hasFunction 'fputs')
		(?fileLibrary pa:hasFunction 'ftell')
		(?fileLibrary pa:hasFunction 'fprintf')
		(?fileLibrary pa:hasFunction 'fscanf')
		(?fileLibrary pa:hasFunction 'fseek')
		(?fileLibrary pa:hasFunction 'ungetc')

		(c:loop pa:maxIterations 1)
		
		(1 1 analyzeStatement(?st, ?pp, ?cond))
		(1 1 execute(pa:firstStatement,?st,?cond,?pp))

]





############################################################################################################################
################################ Analyze If and loop statements ############################################################


# Analyze If statement.
[IfStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),
				
		print('if stmnt 1')
]


# Analyze If statement.
[IfStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(1 1 updateOtherVarCompleted(?st,?cond))
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

->
		remove(1)
		remove(0)		
#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter)),
		(1 1 createNoConditionList(?st,?cond,?exp,?iter,?baseConditions,?st,?iter))
		(1 1 createYesConditionList(?st,?cond,?exp,?iter,?baseConditions,?iter)),

#		(?st pa:previousIterationIndex_0 ?iter)
#		(?st pa:previousIterationIndex_1 ?iter)

		(?st pa:iterationIndex func1(?cond,?iter))
		(?st pa:iterationIndex func0(?cond,?iter))
		(?st pa:stProgramConditions ?cond)

#		(1 1 createYesConditionList2(?st,?cond,?exp,?iter,?baseConditions,?prev,?pp)),
#		(1 1 createNoConditionList2(?st,?cond,?exp,?iter,?baseConditions,?prev,?pp))
				
		print('if stmnt 2')
]



# Analyze return statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ReturnStatement)
#		(?ret rdf:type c:NullExpr)
		(?ret c:hasParent ?st)
		noValue(?ret, c:hasBaseType, c:_IO_FILE)
		(?pp pa:iteration ?iter)
->
		remove(0)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('return', ?st)
]

# Analyze return statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ReturnStatement)
		(?ret c:hasParent ?st )
		(?ret c:referTo ?var)
		(?ret c:hasBaseType c:_IO_FILE)
		(?pp pa:iteration ?iter)
->
		remove(0)
		(1 1 makePS2(?var , ?pp, ?cond,"0"^^xsd:integer,pa:equals))
#return fp is as good as fclose(fp)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('return with Value', ?st)
]


# Analyze break statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:BreakStatement)
		(?pp pa:iteration ?iter)
->
		remove(0)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('break')
]

# Analyze Continue statement.
[ContinueStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ContinueStatement)
		(?pp pa:iteration ?iter)
		
->
		remove(0)
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
		print('Continue')
]


# exit
[exitFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'exit'),
#		(?func c:hasArgumentExpr ?y),
#		(?y c:NthArg "0"),
#		(?y c:referTo ?op)
#		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
#		(1 1 makePS2(?op , ?pp, ?cond,"0"^^xsd:integer,pa:equals))
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
#		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('exit')
]



############################################################################################################################
################################ Make Variable states and conditions #######################################################



# yes and No condition list can be merged?


[createYesConditionList:
		(1 1 createYesConditionList(?prev,?cond,?exp,?iter,?baseConditions,?iterIndex)),
		makeTemp(?cond2)
		

->
		remove(0)
		(?cond2 rdf:type rdf:List)
		(?cond2 rdf:first ?cond),
		(?cond2 rdf:rest ?cond),	

		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),

		(1 1 updateOtherVarCompleted(?prev,?cond2))
		(1 1 completedYesCondition(?prev,?cond2,?iter,?baseConditions))
#		(?prev pa:iterationIndexEnable_1 ?cond2)
#		(?prev pa:iterationIndex func1(?cond2,?iterIndex))
		print(' yes condition',?prev,?cond2)
		
#		(1 pa:output completedYesCondition(?prev,?cond2,?iter,?baseConditions))
#		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))

]



[createNoConditionList:
		(1 1 createNoConditionList(?prev,?cond,?exp,?iter,?baseConditions,?forSt,?iterIndex)),
		makeTemp(?cond2)
		
->
		remove(0)
		(?cond2 rdf:type rdf:List)
		(?cond2 rdf:first ?cond),
		(?cond2 rdf:rest ?cond),	

		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),

		(1 1 updateOtherVarCompleted(?prev,?cond2))
		(1 1 completedNoCondition(?prev,?cond2,?iter,?baseConditions)),
#		(?forSt pa:iterationIndexEnable_0 ?cond2)
#		(?forSt pa:iterationIndex func0(?cond2,?iterIndex))
		print('completed no condition',?prev,?cond2)

#		(1 pa:output completedNoCondition(?prev,?cond2,?iter,?baseConditions))
#		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))

]

#called only from forSt1 and forSt2
[createYesConditionList2:
		(1 1 createYesConditionList2(?prev,?cond,?exp,?iter,?baseConditions,?prevprev,?pp)),
#		difference(?iter,1,?prevIter),
		makeTemp(?cond2)
		makeTemp(?pp2)
		
		(?prevPP pa:afterStatement ?prevprev),
		(?prevPP pa:hasProgramConditions ?cond),
		(?prevPP pa:iteration ?prevIter)
		(?prevPP pa:baseConditions ?baseConditions)
->
		remove(0)
		(?cond2 rdf:type rdf:List)
		(?cond2 rdf:first ?cond),
		(?cond2 rdf:rest ?cond),	

		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond2),
		(?pp2 pa:iteration ?iter)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prevprev,?prev,?cond2,?pp2,1,?prevIter,?iter))
		(1 1 completedYesCondition(?prev,?cond2,?iter,?baseConditions))
		print(' yes condition 2','prevprev',?prevprev,'prev',?prev)

#		(1 pa:output completedYesCondition(?prev,?cond2,?iter,?baseConditions))
#		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))


]


#called only from forSt3
[createNoConditionList2:
		(1 1 createNoConditionList2(?prev,?cond,?exp,?iter,?baseConditions,?prevprev,?pp,?forSt)),
		
#		(?forSt pa:iterationIndex funcTemp(?iterCond,?iterIndex))
#relation between ?cond and ?iterCond

		makeTemp(?cond2)
		(?prevPP pa:afterStatement ?prevprev),
		(?prevPP pa:hasProgramConditions ?cond),
		(?prevPP pa:iteration ?prevIter)
		(?prevPP pa:baseConditions ?baseConditions)
		
->
		remove(0)
		(?cond2 rdf:type rdf:List)
		(?cond2 rdf:first ?cond),
		(?cond2 rdf:rest ?cond),	

		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),

		(1 1 updateOtherVar(?prevprev,?prev,?cond2,?pp,1,?prevIter,?iter))
		(1 1 completedNoCondition(?prev,?cond2,?iter,?baseConditions)),
		print('completed no condition2','prevprev',?prevprev,'prev',?prev)

#		(1 pa:output completedNoCondition(?prev,?cond2,?iter,?baseConditions))
#		(1 pa:parameterList parameter(?prev,?cond2,?iter,?baseConditions,?cond))

#		(?forSt pa:iterationIndexEnable_1 ?cond2)
#		(?forSt pa:iterationIndex func1(?cond2,?iterIndex))

]


# Different ways of making variable states
[makePointerState1:
		(1 1 makePS(?var, ?pp, ?cond)),
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(1 1 completed(?var,?cond,?iter,?baseConditions))
		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make ps',?var)
]

[makePointerState2:
		(1 1 makePS2(?var, ?pp, ?cond,?stateVal, ?stateRel))
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		noValue(1,1,updateVarList(?var,?z1))
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		remove(0)
#		(1 1 completed(?var,?cond,?iter))
#		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make ps2')
]

[makeFilePointerState:
		(1 1 makeFilePS(?var, ?pp, ?cond,?stateVal, ?stateRel,?resource))
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		noValue(1,1,updateVarList(?var,?z1))
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:pointsToResource ?resource),
		(?ps pa:atProgramPoint ?pp),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		remove(0)
#		(1 1 completed(?var,?cond,?iter))
#		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make file ps')
]

[makePointerState_completed:
		(1 1 makePS_comp(?var, ?pp, ?cond,?stateVal, ?stateRel))
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		noValue(1,1,updateVarList(?var,?z1))
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		remove(0)
#		(1 1 completed(?var,?cond,?iter))
		(1 1 updateOtherVarCompleted(?var,?cond))
		print('make ps_other var completed')
]

		

# List of variables
[updateVarList:
		(1 1 updateVarList(?st,?baseConditions,?cond))
		(?varList rdf:type pa:varList)
		(?varList pa:count ?c)
		addOne(?c,?c1)
		noValue(?varList,rdf:item,?st)
		(?st rdf:type c:Variable)
		(?varList pa:baseConditions ?baseConditions)

#		(?varList pa:inPath ?cond)
		(?varList pa:inFunction ?func)
		(?st c:hasScope ?func)

->
		(?varList rdf:item ?st)
		remove(0)
		remove(2)
		(?varList pa:count ?c1)

		print('varList', ?c1, ?func)

]

[updateOtherVar0:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		noValue(pa:otherVarCount ?t2 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		notEqual(?currVar,1)
		noValue(1, 1, makePS2(?next, ?pp, ?cond,?stateVal, ?stateRel))
		noValue(1,1,updateVarList(?currVar,?z1))
		noValue(1,1,makeFilePS(?next, ?pp, ?cond,?stateVal, ?stateRel,?resource))

->
		(pa:otherVarCount 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 0_1',?next)
]


[updateOtherVar0:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		noValue(pa:otherVarCount ?t2 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		equal(?currVar,1)
		noValue(1, 1, makePS2(?next, ?pp, ?cond,?stateVal, ?stateRel))
		noValue(1,1,updateVarList(?z2,?z1))
		noValue(1,1,makeFilePS(?next, ?pp, ?cond,?stateVal, ?stateRel,?resource))

#(?varList rdf:type pa:varList)
#		(?varList pa:inPath ?cond)
#		(?varList pa:count ?c)

->
		(pa:otherVarCount 0 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 0_0',?next)
#		print('var count',?c)

]

#update programPoint of other vars.
#applied when prev is not cfg exit of for statement
#when prev and next are in same iteration
[updateOtherVar:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		(pa:otherVarCount ?cnt updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		addOne(?cnt,?cnt1)
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		(?varList pa:baseConditions ?baseConditions)
		(?pp pa:baseConditions ?baseConditions)		
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?prevIter)
		(?pp pa:iteration ?iter)
		noValue(?ps pa:atProgramPoint ?pp)


		
->
		(?ps pa:atProgramPoint ?pp)
		remove(1)
		(pa:otherVarCount ?cnt1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
#		print('update other Var 1',?var,'st:',?next)

]



[updateOtherVarComplete:
		(1 1 updateOtherVar(?prev,?next,?cond,?pp,?currVar,?prevIter,?iter)),
		(?varList rdf:type pa:varList)
		(?varList pa:count ?c)
		(pa:otherVarCount ?cnt1 updateOtherVar(?prev,?next,?cond,?pp,?currVar))
		equal(?c,?cnt1)
		(?varList pa:baseConditions ?baseConditions)
#		(?varList pa:inPath ?cond)
		(?pp pa:baseConditions ?baseConditions)		
		
->
		remove(0)
		remove(3)
		(1 1 updateOtherVarCompleted(?next,?cond))
#		print('update other var completed','count',?c,'st',?next)
]


##################################################################################################################
################################ Pass Control ####################################################################

# if the previous statement is not a conditional
[passControl:
		(1 1 completed(?prev,?cond,?iter,?baseConditions)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
		noValue(?prev, pa:lastStatementInLoop)
		(?prev pa:nextStatement ?next),
		makeTemp(?pp)
->
		remove(1)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next,'pass control 1','iter',?iter)
		print('')
]


[passControl4:
		(1 1 completedForIncr(?prev,?cond,?forSt,?i,?baseConditions)),
#		(1 1 updateOtherVarCompleted(?prev,?cond))

		(?prev pa:nextStatement ?next),
		makeTemp(?pp)
->
		remove(0)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?i)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute2(?prev,?next,?cond,?pp,?i)),
		print(?prev, ?next, 'pass control 4')
		print('')
]


# if the previous statement is an If conditional
[passControl2:
		(1 1 completedYesCondition(?prev,?cond,?iter,?baseConditions)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
		(?prev pa:nextTrueStatement ?next),
		makeTemp(?pp)
->
		remove(1)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'true','iter',?iter)
		print('')
]

# if the previous statement is an If conditional
[passControl3:
		(1 1 completedNoCondition(?prev,?cond,?iter,?baseConditions)),
		(1 1 updateOtherVarCompleted(?prev,?cond))
#removed comment above line on feb 6
		(?prev pa:nextFalseStatement ?next),
		makeTemp(?pp)

->
		remove(1)
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'false')
		print('')
]


