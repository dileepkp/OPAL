@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .


##################################################################################################################################
################################ true rules ######################################################################################



# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_1 ?index)	
#		(?par pa:iterationIndexEnable_1 ?cond2)	
		(?par pa:iterationIndex func1(?cond2,?index))

		equal(?cond,?cond2)
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		
->
		remove(0)		
#		remove(1)
#		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true',?st)
]



# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_1 ?index)	
#		(?par pa:iterationIndexEnable_1 ?cond2)	
		(?par pa:iterationIndex func1(?cond2,?index))

		
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		notEqual(?cond,?cond2)		
		(?cond rdf:item ?cond2)


		
->
		remove(0)		
#		remove(1)
#		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true2',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_1 ?index)	
#		(?par pa:iterationIndexEnable_1 ?cond2)	
		(?par pa:iterationIndex func1(?cond2,?index))

		
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		
->
		remove(0)		
#		remove(1)
#		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true3',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_1 ?index)	
#		(?par pa:iterationIndexEnable_1 ?cond2)	
		(?par pa:iterationIndex func1(?cond2,?index))

		
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond4)
		(?cond4 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		notEqual(?cond4,?cond2)

		
->
		remove(0)		
#		remove(1)
#		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true4',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_1 ?index)	
#		(?par pa:iterationIndexEnable_1 ?cond2)	
		(?par pa:iterationIndex func1(?cond2,?index))

		
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond4)
		(?cond4 rdf:item ?cond5)
		(?cond5 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		notEqual(?cond4,?cond2)
		notEqual(?cond5,?cond2)

		
->
		remove(0)		
#		remove(1)
#		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true5',?st)
]


# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
#		(?par pa:previousIterationIndex_1 ?index)	
#		(?par pa:iterationIndexEnable_1 ?cond2)	
		(?par pa:iterationIndex func1(?cond2,?index))

		
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
		(?st c:hasParent ?par)
		makeTemp(?pp2)

		(?cond rdf:item ?cond3)
		(?cond3 rdf:item ?cond4)
		(?cond4 rdf:item ?cond5)
		(?cond5 rdf:item ?cond6)
		(?cond6 rdf:item ?cond2)

		notEqual(?cond,?cond2)
		notEqual(?cond3,?cond2)
		notEqual(?cond4,?cond2)
		notEqual(?cond5,?cond2)
		notEqual(?cond6,?cond2)

		
->
		remove(0)		
#		remove(1)
#		remove(2)

		(?pp2 rdf:type pa:ProgramPoint),
		(?pp2 pa:afterStatement ?prev),
		(?pp2 pa:hasProgramConditions ?cond),
		(?pp2 pa:iteration ?index)
		(?pp2 pa:baseConditions ?baseConditions)

		(1 1 updateOtherVar(?prev,?st,?cond,?pp2,1,?iter,?index)),

		(1 1 completed(?st,?cond,?index,?baseConditions))
		print('dummy cfg exit true6',?st)
]

