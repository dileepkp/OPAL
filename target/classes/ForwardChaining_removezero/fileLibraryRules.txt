@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .




# Variable declaration with function call of library
#File * fp = fopen(..);
[varDecFuncCall:
		(1 1 execute(?prev,?var,?cond,?pp)),
		(?var rdf:type c:Variable),
		(?var c:hasType c:pointer_type),
		(?var c:hasInitializer ?init),
		(?init rdf:type c:AssignInitializer),
		(?init c:hasInitialValue ?func),
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fopen'),
		makeTemp(?ps)
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)
->
		remove(0)
# function call is the resource

		(1 1 updateVarList(?var,?baseConditions,?cond))
		(1 1 makeFilePS(?var , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual,?func))
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,?var,?iter,?iter)),
		(1 1 completed(?var,?cond,?iter,?baseConditions))
		print('file var declaration with fopen')

]


#File * fp; fp = fopen(..);
[fopenReturn2: 
		(1 1 execute(?prev,?exp,?cond,?pp))
		(?exp rdf:type c:ExpressionStatement )
		(?exp c:hasExpression ?func )
		(?func rdf:type c:AssignOp )
		(?func c:hasLeftOperand ?left )
		(?func c:hasRightOperand ?funcCall )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?expRef )
		(?funcCall rdf:type c:FunctionCall)
		(?funcCall c:call ?call)
		(?call c:hasName 'fopen')

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		(1 1 makeFilePS(?expRef , ?pp, ?cond,"0"^^xsd:integer,pa:greaterEqual,?funcCall))

		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?expRef,?iter,?iter)),
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('file: fopen2')
]



#A file pointer variable declaration without assignment
#File *f in parameter list
[analyzeFirstStatement1:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:Variable),
		(?st c:hasType c:pointer_type)
		(?st c:hasBaseType c:_IO_FILE)
		(?st c:NthPara ?paraNum)
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)
->
		remove(0)
		(1 1 updateVarList(?st,?baseConditions,?cond))
		(1 1 makePS2(?st , ?pp, ?cond,pa:unknown,pa:equals))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?st,?iter,?iter)),
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		print('file parameter in function parameter list')
]


#A pointer file variable declaration without assignment
[analyzeFirstStatement1:

		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:Variable),
		noValue(?st,c:hasInitializer),
		noValue(?st,pa:tempStateValue),
		(?st c:hasType c:pointer_type)
		(?st c:hasBaseType c:_IO_FILE)
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)
->
		remove(0)
		(1 1 updateVarList(?st,?baseConditions,?cond))
		(1 1 makePS2(?st , ?pp, ?cond,pa:unknown,pa:equals))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?st,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		print('FILE fp pointer;')


]



# Assignment Statement fp1 = fp2
[forInitStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		(?right c:referTo ?var2),
		(?left c:hasBaseType c:_IO_FILE)
		(?right c:hasBaseType c:_IO_FILE)
# in the above two clauses, we can use var and var2 also, no problem

		(?var2 pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?ps pa:pointsToResource ?resource)
		(?ps pa:stateValue ?stateVal),
		(?ps pa:stateRelation ?stateRel),
		(?prevPP pa:afterStatement ?prev)
		(?prevPP pa:iteration ?iter)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

		
->
		remove(0)
#		(?var pa:hasPointerState ?ps)

		(1 1 updateVarList(?var,?baseConditions,?cond))
#need above one for global variables. nothing harm in invoking the above clause
		(1 1 makeFilePS(?var , ?pp, ?cond,?stateVal,?stateRel,?resource))
		print('file Assignment Statement type fp1 = fp2;'),
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
]



###############################################################################################################################
################################ Analyze file library statements ##############################################################



# Library function call
# fputc(*Data,f);
[fputcFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputc'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:IndirectionOp),
		(?x1 c:hasOperand ?x2),
		(?x2 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('fputc')
]



# Library function call
# fputc(*Data,f);
[fputcFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputc'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:VariableRef),
#		(?x1 c:hasOperand ?x2),
		(?x1 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('fputc 2')
]


# Library function call
# fputs(" ",f);
[fputsFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputs'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),

		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:Value),
#		(?x1 c:hasOperand ?x2),
#		(?x2 c:referTo ?op1),

		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('fputs')
]

# ch = fgetc(fin);
[fgetcCall:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?func )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fgetc'),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		print('fgetc func call', 'iter', ?iter),
		(1 1 makePS2(?var , ?pp, ?cond,pa:unknown,pa:equals))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]


# ch = ftell(fin);
[ftellCall:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement )
		(?st c:hasExpression ?expr )
		(?expr rdf:type c:AssignOp )
		(?expr c:hasLeftOperand ?left )
		(?expr c:hasRightOperand ?hro )
		(?left rdf:type c:VariableRef )
		(?left c:referTo ?var )
		(?hro c:hasOperand ?func)
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'ftell'),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		print('ftell func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
]


# Library function call
# fprintf
[fprintfFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fprintf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		print('fprintf func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]


# Library function call
# fseek
[fseekFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fseek'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		print('fseek func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]


# Library function call
# fscanf
[fscanfFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fscanf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		print('fscanf func call', 'iter', ?iter),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]



# Library function call
# ungetc
[ungetcFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName ?funcName),
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

		(?ignoreFuncCalls rdf:type pa:ignoreFuncCalls)
		(?ignoreFuncCalls rdf:item ?funcName)
->
		remove(0)
		print('ignore func call', ?funcName),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
]

# fclose(f);
[fcloseFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fclose'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op)
		makeTemp(?ps)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		remove(0)
		(1 1 makePS2(?op , ?pp, ?cond,"0"^^xsd:integer,pa:equals))
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?op,?iter,?iter))
		(1 1 completed(?exp,?cond,?iter,?baseConditions))
		print('fclose')
]




