@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .




##################################################################################################################################
################################ Skip rules for Variable Declarations ############################################################


# skip not valid pointer type;
[rule:
		(1 1 execute(?prev,?st,?cond,?pp))
		(?st rdf:type c:Variable),
		(?st c:hasType c:pointer_type)
		(?st c:hasBaseType ?dt)
		noValue(?st,c:hasInitializer),

		noValue(?st,  c:hasBaseType, c:_IO_FILE)	
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList, rdf:item, ?dt)


->
		print('skip not valid pointer type;')
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]

# skip not valid scalar type;
[rule:
		(1 1 execute(?prev,?st,?cond,?pp))
		(?st rdf:type c:Variable),
		noValue(?st,c:hasType,c:pointer_type)
		(?st c:hasType ?dt)
		noValue(?st,c:hasInitializer),
	
		(?pp pa:baseConditions ?baseConditions)
		(?pp pa:iteration ?iter)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList, rdf:item, ?dt)


->
		print('skip not valid scalar type;')
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]


# skip not valid pointer type declaration with assignment
[rule:
		(1 1 execute(?prev,?vardecl,?cond,?pp))
		(?vardecl rdf:type c:Variable)
		(?vardecl c:hasType c:pointer_type)
		(?vardecl c:hasInitializer ?assign)
		(?vardecl c:hasBaseType ?dt)
		
		noValue(?vardecl, c:hasBaseType, c:_IO_FILE)
		(?assign rdf:type c:AssignInitializer)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList, rdf:item, ?dt)



		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

->


		(1 1 completed(?vardecl,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?vardecl,?cond,?pp,1,?iter,?iter))

]


# skip not valid scalar type i=0;
[rule:
		(1 1 execute(?prev,?vardecl,?cond,?pp))
		(?vardecl rdf:type c:Variable)
		noValue(?vardecl,c:hasType,c:pointer_type)
		(?vardecl c:hasInitializer ?assign)
		(?vardecl c:hasType ?dt)
		
		(?assign rdf:type c:AssignInitializer)

		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList, rdf:item, ?dt)



		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

->


		(1 1 completed(?vardecl,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?vardecl,?cond,?pp,1,?iter,?iter))

]

##################################################################################################################################
################################ Skip rules for Variable assignments ############################################################


# skip Assignment Statement i = <expression> ; i not valid pointer
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		(?var c:hasType c:pointer_type)
		(?var c:hasBaseType ?dt)


		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList, rdf:item, ?dt)

		noValue(?var, c:hasBaseType, c:_IO_FILE)


		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)



		
->
		
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]

# skip Assignment Statement i = <expression> ; i not scalar
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		noValue(?var, c:hasType, c:pointer_type)
		(?var c:hasType ?dt)


		(?intDataTypeList rdf:type pa:intDataTypeList)
		noValue(?intDataTypeList, rdf:item, ?dt)


		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)



		
->
		
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]


# skip Assignment Statement i = (cast)<expression> 
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var)
		(?right rdf:type c:CastOp)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)



		
->
		print('cast op skip', ?st)	
	(1 1 makePS2(?var, ?pp, ?cond,pa:unknown, pa:equals))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
]



# skip Assignment Statement i = member_ref 
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var)
		(?right rdf:type c:MemberRef)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)



		
->
		print('member ref op skip', ?st)	
	(1 1 makePS2(?var, ?pp, ?cond,pa:unknown, pa:equals))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
]



# skip Assignment Statement i = array_sub 
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var)
		(?right rdf:type c:ArraySub)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)



		
->
		print('ArraySub op skip', ?st)	
	(1 1 makePS2(?var, ?pp, ?cond,pa:unknown, pa:equals))
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var,?iter,?iter))
]





[arrayVariableAssignment:
		(1 1 execute(?prev,?st,?cond,?pp))
		(?st rdf:type c:ExpressionStatement)
		(?st c:hasExpression ?expr)
		(?expr rdf:type c:AssignOp)
		(?expr c:hasLeftOperand ?left)
		(?left rdf:type c:ArraySub)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
#		print('arrayVariableAssignment')
]

[switchStatement:
		(1 1 execute(?prev,?st,?cond,?pp))
		(?st rdf:type c:SwitchStatement)
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
#		print('switchStatement')
]


# Assignment Statement i = j; i indirectionop type
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left rdf:type c:IndirectionOp)
		
		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)
->
		
#		print('Assignment Statement i = j; i indirectionop type '),
#		(1 1 makePS2(?var , ?pp, ?cond,?concreteVal,pa:equals))

		(1 1 completed(?st,?cond,?iter,?baseConditions))
(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]




# ternary operator
[rule:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),

		(?right rdf:type c:ConditionalOp),
		(?left c:hasType ?dt)
		noValue(?left,c:hasBaseType,c:_IO_FILE)

		(?pp pa:iteration ?iter)
		(?pp pa:baseConditions ?baseConditions)

#		(?intDataTypeList rdf:type pa:intDataTypeList)
#		noValue(?intDataTypeList,rdf:item,?dt)
	
		
->
		
#		print('Skip Assignment Statement type i = if-else in shortcut'),
		(1 1 completed(?st,?cond,?iter,?baseConditions))
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1,?iter,?iter))
]


