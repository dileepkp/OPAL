@prefix c: <http://www.semanticweb.org/yzhao30/ontologies/2015/7/c#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix pa: <http://www.semanticweb.org/aidb/ontologies/BugFindingOntology#> .
@prefix fl: <http://www.semanticweb.org/aidb/ontologies/FileLibraryOntology#> .
@prefix file0: <ftp:/home/demo/Downloads/PATO-ROSE-master/tools/onto-build-rose/test/word2vec.c#> .

@include <fileLibraryRules.txt>.

[beginExecution:
#		(?st rdf:type pa:beginExecutionStatement),
		(?st pa:beginExecutionInFunction file0:415_18_420_1 ),
		makeTemp(?pp), 
		makeTemp(?cond),
#list of variables
		makeTemp(?varList)
		
->
#		print('begin execution'),
		(?pp rdf:type pa:ProgramPoint),
		(?cond rdf:type pa:conditionList),
		(?cond rdf:item 'true'),
#		(?cond rdf:rest rdf:nil),
		(?pp pa:afterStatement ?st),
		(?pp pa:hasProgramConditions ?cond),
		(?varList rdf:type rdf:list),
		(?varList rdf:type pa:varList),
		(1 1 analyzeStatement(?st, ?pp, ?cond))

]

#A pointer variable declaration without assignment
[analyzeFirstStatement1:
		(1 1 analyzeStatement(?st, ?pp, ?cond)),
		(?st rdf:type c:Variable),
		noValue(?st,c:hasInitializer),
		(?st c:hasType c:pointer_type)
->
		(1 1 makePS(?st, ?pp, ?cond)),
		(1 1 updateVarList(?st))
]

#A long long variable declaration without assignment
[analyzeFirstStatement2:
		(1 1 analyzeStatement(?st, ?pp, ?cond)),
		(?st rdf:type c:Variable),
		noValue(?st,c:hasInitializer),
		(?st c:hasType c:long_long)
->
		(1 1 updateVarList(?st))
		(1 1 makePS(?st, ?pp, ?cond))
		
#		print('analyze first statement')
]




###############################################################################################################################
################################ Analyze other types of statements ############################################################

# ForInit Statemen
[forInitStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ForInitStatement)
		(?st c:hasExpression ?expr),
		(?expr rdf:type c:AssignOp),
		(?expr c:hasLeftOperand ?left),
		(?expr c:hasRightOperand ?right),
		(?left c:referTo ?var),
		(?right c:hasOperand ?val),
		(?val rdf:type c:Value),
		(?val c:hasValue ?concreteVal),
		(?val c:hasType c:int),
		makeTemp(?ps),
		makeTemp(?temp)
->
		
		(?var pa:hasPointerStateInLoop ?ps),
		(?ps pa:atProgramPoint ?pp),
		print('for init'),
		(?ps pa:stateValue ?concreteVal),
		(?ps pa:stateRelation  pa:equals),
		(?ps pa:iteration 0)
		(1 1 updateOtherVarInLoopEntry(?prev,?st,?cond,?pp,?var)),
		(1 1 completed(?st,?cond))
		(?temp rdf:type pa:loopVarList),
		(?temp rdf:item ?var)
]


# ForIncr Statemen
[forIncrStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
(?st rdf:type c:PostfixIncrementOp)
(?st c:hasParent ?forSt)
		(?forSt c:hasForIncr ?st)
 (?forSt pa:iteration ?i)
		 addOne(?i,?newI)		
		(?st c:hasOperand ?operand)
		(?st c:hasType c:long_long)
		(?operand rdf:type c:VariableRef)
		(?operand c:referTo ?var)
		makeTemp(?ps)
		(?varList rdf:type pa:varList)		
		(?varList rdf:item ?var)
		(?var pa:hasPointerState ?ps2),
		(?ps2 pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		(?ps2 pa:stateValue ?concreteVal)
		addOne(?concreteVal,?newVal)

->
		
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		print('for incr'),
#		print(?concreteVal),
		(?ps pa:stateValue ?newVal),
		(?ps pa:stateRelation  pa:equals),
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?var)),
#		(?forSt pa:iteration ?newI)
		
		(1 1 completedForIncr(?st,?cond,?forSt,?newI))
		remove(4)
#		(1 1 updateForIncr(?forSt,?newI))

]
###############################################################################################################################
################################ Analyze file library statements ##############################################################


# Variable declaration with function call of library
[varDecFuncCall:
		(1 1 execute(?prev,?var,?cond,?pp)),
		(?var rdf:type c:Variable),
		(?var c:hasType c:pointer_type),
		(?var c:hasInitializer ?init),
		(?init rdf:type c:AssignInitializer),
		(?init c:hasInitialValue ?func),
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fopen'),
		makeTemp(?ps)
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?call pa:hasName  fl:fopen),
		(1 1 invoke(?var, ?pp, ?cond)),
		(1 1 updateVarList(?var))
		(1 1 updateOtherVar(?prev,?var,?cond,?pp,?var)),
#		(1 1 makePS(?var, ?pp, ?cond))
]


# Library function call
# fputc(*Data,f);
[fputcFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fputc'),
		(?func c:hasArgumentExpr ?x),
		(?x c:NthArg "0"),
		(?x c:hasOperand ?x1),
		(?x1 rdf:type c:IndirectionOp),
		(?x1 c:hasOperand ?x2),
		(?x2 c:referTo ?op1),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "1"),
		(?y c:referTo ?op2)
->
		(?call pa:hasName  fl:fputc)
		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1))
print('fputc')
]



# Library function call
# fprintf
[fprintfFunCall:
		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement),
		(?exp c:hasExpression ?func),		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fprintf'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op2)
->
#		(?call pa:hasName  fl:fputc)
#		(1 1 invoke(?exp, ?pp, ?cond)),
		print('fprintf func call'),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,1))
		(1 1 completed(?exp,?cond))
]

# fclose(f);
[fcloseFunCall:

		(1 1 execute(?prev,?exp,?cond,?pp)),
		(?exp rdf:type c:ExpressionStatement)
		(?exp c:hasExpression ?func)		
		(?func rdf:type c:FunctionCall),
		(?func c:call ?call),
		(?call rdf:type c:FunctionRef),
		(?call c:hasName 'fclose'),
		(?func c:hasArgumentExpr ?y),
		(?y c:NthArg "0"),
		(?y c:referTo ?op)
		makeTemp(?ps)
->
		(?op pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(?call pa:hasName  fl:fclose),
		(1 1 invoke(?exp, ?pp, ?cond)),
		(1 1 updateOtherVar(?prev,?exp,?cond,?pp,?op))
print('fclose')
]


############################################################################################################################
################################ Analyze If and loop statements ############################################################


# Analyze If statement.
[IfStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1)),
		(1 1 createYesConditionList(?st,?cond,?exp)),
		(1 1 createNoConditionList(?st,?cond,?exp))
print('if stmnt')
]

# Analyze For statement
[ForStatement1:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ExpressionStatement),
		(?st c:hasParent ?forSt),
		(?forSt rdf:type c:ForStatement),
		noValue(?forSt, pa:iteration)
		(?forSt c:hasForTest ?st)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
(1 1 createNoConditionList(?st,?cond,?st))		
(1 1 createYesConditionList(?st,?cond,?st))

		(?forSt pa:iteration 0)
print('for st1')
]

# Analyze For statement.
[ForStatement2:
		(1 1 execute2(?prev,?st,?cond,?pp,?newI))
		(?st rdf:type c:ExpressionStatement)
		(?st c:hasParent ?forSt)
		(?forSt rdf:type c:ForStatement)
		(?forSt c:hasForTest ?st)
#		(?forSt pa:iteration 1)
# noValue(?forSt pa:iteration 2)
equal(?newI,1)
->

#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
		(1 1 createYesConditionList(?st,?cond,?st))
		(?forSt pa:iteration ?newI)
#		(1 1 createNoConditionList(?st,?cond,?exp))
print('for st2')
]

# Analyze For statement.
[ForStatement3:
		(1 1 execute2(?prev,?st,?cond,?pp,?newI)),
		(?st rdf:type c:ExpressionStatement),
		(?st c:hasParent ?forSt),
		(?forSt rdf:type c:ForStatement),
		(?forSt c:hasForTest ?st)
#		(?forSt pa:iteration 2)
equal(?newI,2)
->
#		(?forSt pa:iteration 3)
#		(1 1 completed(?forSt,?cond))
#		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1)),
#		(1 1 createYesConditionList(?st,?cond,?exp)),
		(1 1 createNoConditionList(?st,?cond,?st))
print('for st3')
]




# Analyze return statement.
[ReturnStatement:
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:ReturnStatement)
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1))
print('return')
]

# If the true conditional block of a if-else statement has a return statement, then 
# the rest of function has a negated condition.
# disabled temporarily
[IfStatementWithReturn:
		(-2 -2 -2),
		(1 1 execute(?prev,?st,?cond,?pp)),
		(?st rdf:type c:IfElseStatement),
		(?st c:hasCondition ?exp),
		(?exp rdf:type c:ExpressionStatement),
		(?st c:hasTrueBody ?trueBody),
		(?trueBody rdf:type c:Block),
		(?return rdf:type c:ReturnStatement),
		(?return c:hasParent  ?trueBody),
		(?st pa:afterIfBlock ?afterIf)
->
		(?afterIf pa:inheritsCondition negOf(?exp))
]

# A dummy exit statement created in cfg.
# Simply pass control to the next statement.
[dummyCFGExit:
		(1 1 execute(?prev,?st,?cond,?pp)),
		strConcat(?st,?st2),
		regex(?st2,'.*exit$')
->
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,1)),
		(1 1 completed(?st,?cond))
print('dummy cfg exit')
]


############################################################################################################################
################################ Make Variable states and conditions #######################################################

# yes and No condition list can be merged?


[createYesConditionList:
		(1 1 createYesConditionList(?prev,?cond,?exp)),
		makeTemp(?cond2)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 rdf:item ?exp),
		(1 1 completedYesCondition(?prev,?cond2))
print(' yes condition')
]


[createNoConditionList:
		(1 1 createNoConditionList(?prev,?cond,?exp)),
		makeTemp(?cond2)
->
		(?cond2 rdf:type pa:conditionList),
		(?cond2 rdf:item ?cond),
		(?cond2 pa:negItem ?exp),
		(1 1 completedNoCondition(?prev,?cond2)),
	print('completed no condition')
]


# Different ways of making variable states
[makePointerState1:
		(1 1 makePS(?var, ?pp, ?cond)),
		makeTemp(?ps)
->
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?pp),
		(1 1 completed(?var,?cond))
# print('make ps')
]

# List of variables
[updateVarList:
		(1 1 updateVarList(?st))
		(?varList rdf:type pa:varList)
		noValue(?varList,rdf:item,?st)
		(?st rdf:type c:Variable)
->
		(?varList rdf:item ?st)
# print('update var list')
#		(?varList rdf:rest rdf:nil)
]


#update programPoint of other vars.
[updateOtherVar:
		(1 1 updateOtherVar(?prev,?st,?cond,?pp,?currVar)),
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		notEqual(?var, ?currVar),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
->
		(?ps pa:atProgramPoint ?pp)
]


#update programPoint of other vars in loops.
#invoke this from ForInit
[updateOtherVarInLoop:
		(1 1 updateOtherVarInLoopEntry(?prev,?st,?cond,?pp,?currVar)),
		(?varList rdf:type pa:varList),		
		(?varList rdf:item ?var),
		(?loopVarList rdf:type pa:loopVarList),		
		notEqual(?var, ?currVar),
		(?st c:hasParent ?forSt),
		(?var pa:hasPointerState ?ps),
		(?ps pa:atProgramPoint ?prevPP),
		(?prevPP pa:afterStatement ?prev)
		makeTemp(?ps2)
->
		(?var pa:hasPointerStateInLoop ?ps2),
		(?ps2 pa:atProgramPoint ?pp),
		(?prevPP pa:afterStatement ?prev)
		(?ps pa:atProgramPoint ?pp)
]



##################################################################################################################
################################ Pass Control ####################################################################

# if the previous statement is not a conditional
[passControl:
		(1 1 completed(?prev,?cond)),
		(?prev pa:nextStatement ?next),
# noValue(1 1 updateForIncr(?forSt,?newI))
		makeTemp(?pp)
->

		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next,'pass control 1')
]


[passControl4:
		(1 1 completedForIncr(?prev,?cond,?forSt,?i)),
		(?prev pa:nextStatement ?next),
#		 addOne(?i,?newI)		
		makeTemp(?pp)
->

		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
# (?forSt pa:iteration ?i)
		(1 1 execute2(?prev,?next,?cond,?pp,?i)),
# (?forSt pa:iteration ?newI)
		print(?prev, ?next, 'pass control 4')
print('pass control4')
]


# if the previous statement is an If conditional
[passControl2:
		(1 1 completedYesCondition(?prev,?cond)),
		(?prev pa:nextTrueStatement ?next),
		makeTemp(?pp)
->
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'true')
]

# if the previous statement is an If conditional
[passControl3:
		(1 1 completedNoCondition(?prev,?cond)),
		(?prev pa:nextFalseStatement ?next),
		makeTemp(?pp)
->
		
		(?pp rdf:type pa:ProgramPoint),
		(?pp pa:afterStatement ?next),
		(?pp pa:hasProgramConditions ?cond),
		(1 1 execute(?prev,?next,?cond,?pp)),
		print(?prev, ?next, 'false')
]


		






